/*
 * kinnek-ng-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 2.4.0 - 2016-12-29
 * License: MIT
 */
angular.module("ui.bootstrap", [ "ui.bootstrap.tpls", "ui.bootstrap.position", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.debounce", "ui.bootstrap.typeahead" ]), 
angular.module("ui.bootstrap.tpls", [ "uib/template/modal/window.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html" ]), 
angular.module("ui.bootstrap.position", []).factory("$uibPosition", [ "$document", "$window", function($document, $window) {
    var SCROLLBAR_WIDTH, BODY_SCROLLBAR_WIDTH, OVERFLOW_REGEX = {
        normal: /(auto|scroll)/,
        hidden: /(auto|scroll|hidden)/
    }, PLACEMENT_REGEX = {
        auto: /\s?auto?\s?/i,
        primary: /^(top|bottom|left|right)$/,
        secondary: /^(top|bottom|left|right|center)$/,
        vertical: /^(top|bottom)$/
    }, BODY_REGEX = /(HTML|BODY)/;
    return {
        getRawNode: function(elem) {
            return elem.nodeName ? elem : elem[0] || elem;
        },
        parseStyle: function(value) {
            return value = parseFloat(value), isFinite(value) ? value : 0;
        },
        offsetParent: function(elem) {
            function isStaticPositioned(el) {
                return "static" === ($window.getComputedStyle(el).position || "static");
            }
            elem = this.getRawNode(elem);
            for (var offsetParent = elem.offsetParent || $document[0].documentElement; offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent); ) offsetParent = offsetParent.offsetParent;
            return offsetParent || $document[0].documentElement;
        },
        scrollbarWidth: function(isBody) {
            if (isBody) {
                if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
                    var bodyElem = $document.find("body");
                    bodyElem.addClass("uib-position-body-scrollbar-measure"), BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth, 
                    BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0, 
                    bodyElem.removeClass("uib-position-body-scrollbar-measure");
                }
                return BODY_SCROLLBAR_WIDTH;
            }
            if (angular.isUndefined(SCROLLBAR_WIDTH)) {
                var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
                $document.find("body").append(scrollElem), SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth, 
                SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0, scrollElem.remove();
            }
            return SCROLLBAR_WIDTH;
        },
        scrollbarPadding: function(elem) {
            elem = this.getRawNode(elem);
            var elemStyle = $window.getComputedStyle(elem), paddingRight = this.parseStyle(elemStyle.paddingRight), paddingBottom = this.parseStyle(elemStyle.paddingBottom), scrollParent = this.scrollParent(elem, !1, !0), scrollbarWidth = this.scrollbarWidth(BODY_REGEX.test(scrollParent.tagName));
            return {
                scrollbarWidth: scrollbarWidth,
                widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
                right: paddingRight + scrollbarWidth,
                originalRight: paddingRight,
                heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
                bottom: paddingBottom + scrollbarWidth,
                originalBottom: paddingBottom
            };
        },
        isScrollable: function(elem, includeHidden) {
            elem = this.getRawNode(elem);
            var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal, elemStyle = $window.getComputedStyle(elem);
            return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
        },
        scrollParent: function(elem, includeHidden, includeSelf) {
            elem = this.getRawNode(elem);
            var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal, documentEl = $document[0].documentElement, elemStyle = $window.getComputedStyle(elem);
            if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) return elem;
            var excludeStatic = "absolute" === elemStyle.position, scrollParent = elem.parentElement || documentEl;
            if (scrollParent === documentEl || "fixed" === elemStyle.position) return documentEl;
            for (;scrollParent.parentElement && scrollParent !== documentEl; ) {
                var spStyle = $window.getComputedStyle(scrollParent);
                if (excludeStatic && "static" !== spStyle.position && (excludeStatic = !1), !excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) break;
                scrollParent = scrollParent.parentElement;
            }
            return scrollParent;
        },
        position: function(elem, includeMagins) {
            elem = this.getRawNode(elem);
            var elemOffset = this.offset(elem);
            if (includeMagins) {
                var elemStyle = $window.getComputedStyle(elem);
                elemOffset.top -= this.parseStyle(elemStyle.marginTop), elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
            }
            var parent = this.offsetParent(elem), parentOffset = {
                top: 0,
                left: 0
            };
            return parent !== $document[0].documentElement && (parentOffset = this.offset(parent), 
            parentOffset.top += parent.clientTop - parent.scrollTop, parentOffset.left += parent.clientLeft - parent.scrollLeft), 
            {
                width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
                height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
                top: Math.round(elemOffset.top - parentOffset.top),
                left: Math.round(elemOffset.left - parentOffset.left)
            };
        },
        offset: function(elem) {
            elem = this.getRawNode(elem);
            var elemBCR = elem.getBoundingClientRect();
            return {
                width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
                height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
                top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
                left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
            };
        },
        viewportOffset: function(elem, useDocument, includePadding) {
            elem = this.getRawNode(elem), includePadding = includePadding !== !1;
            var elemBCR = elem.getBoundingClientRect(), offsetBCR = {
                top: 0,
                left: 0,
                bottom: 0,
                right: 0
            }, offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem), offsetParentBCR = offsetParent.getBoundingClientRect();
            if (offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop, offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft, 
            offsetParent === $document[0].documentElement && (offsetBCR.top += $window.pageYOffset, 
            offsetBCR.left += $window.pageXOffset), offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight, 
            offsetBCR.right = offsetBCR.left + offsetParent.clientWidth, includePadding) {
                var offsetParentStyle = $window.getComputedStyle(offsetParent);
                offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop), offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom), 
                offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft), offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
            }
            return {
                top: Math.round(elemBCR.top - offsetBCR.top),
                bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
                left: Math.round(elemBCR.left - offsetBCR.left),
                right: Math.round(offsetBCR.right - elemBCR.right)
            };
        },
        parsePlacement: function(placement) {
            var autoPlace = PLACEMENT_REGEX.auto.test(placement);
            return autoPlace && (placement = placement.replace(PLACEMENT_REGEX.auto, "")), placement = placement.split("-"), 
            placement[0] = placement[0] || "top", PLACEMENT_REGEX.primary.test(placement[0]) || (placement[0] = "top"), 
            placement[1] = placement[1] || "center", PLACEMENT_REGEX.secondary.test(placement[1]) || (placement[1] = "center"), 
            autoPlace ? placement[2] = !0 : placement[2] = !1, placement;
        },
        positionElements: function(hostElem, targetElem, placement, appendToBody) {
            hostElem = this.getRawNode(hostElem), targetElem = this.getRawNode(targetElem);
            var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop("offsetWidth"), targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop("offsetHeight");
            placement = this.parsePlacement(placement);
            var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem), targetElemPos = {
                top: 0,
                left: 0,
                placement: ""
            };
            if (placement[2]) {
                var viewportOffset = this.viewportOffset(hostElem, appendToBody), targetElemStyle = $window.getComputedStyle(targetElem), adjustedSize = {
                    width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
                    height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
                };
                if (placement[0] = "top" === placement[0] && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? "bottom" : "bottom" === placement[0] && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? "top" : "left" === placement[0] && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? "right" : "right" === placement[0] && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? "left" : placement[0], 
                placement[1] = "top" === placement[1] && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? "bottom" : "bottom" === placement[1] && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? "top" : "left" === placement[1] && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? "right" : "right" === placement[1] && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? "left" : placement[1], 
                "center" === placement[1]) if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                    var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
                    viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? placement[1] = "left" : viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left && (placement[1] = "right");
                } else {
                    var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
                    viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? placement[1] = "top" : viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top && (placement[1] = "bottom");
                }
            }
            switch (placement[0]) {
              case "top":
                targetElemPos.top = hostElemPos.top - targetHeight;
                break;

              case "bottom":
                targetElemPos.top = hostElemPos.top + hostElemPos.height;
                break;

              case "left":
                targetElemPos.left = hostElemPos.left - targetWidth;
                break;

              case "right":
                targetElemPos.left = hostElemPos.left + hostElemPos.width;
            }
            switch (placement[1]) {
              case "top":
                targetElemPos.top = hostElemPos.top;
                break;

              case "bottom":
                targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
                break;

              case "left":
                targetElemPos.left = hostElemPos.left;
                break;

              case "right":
                targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
                break;

              case "center":
                PLACEMENT_REGEX.vertical.test(placement[0]) ? targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2 : targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
            }
            return targetElemPos.top = Math.round(targetElemPos.top), targetElemPos.left = Math.round(targetElemPos.left), 
            targetElemPos.placement = "center" === placement[1] ? placement[0] : placement[0] + "-" + placement[1], 
            targetElemPos;
        },
        adjustTop: function(placementClasses, containerPosition, initialHeight, currentHeight) {
            if (placementClasses.indexOf("top") !== -1 && initialHeight !== currentHeight) return {
                top: containerPosition.top - currentHeight + "px"
            };
        },
        positionArrow: function(elem, placement) {
            elem = this.getRawNode(elem);
            var innerElem = elem.querySelector(".tooltip-inner, .popover-inner");
            if (innerElem) {
                var isTooltip = angular.element(innerElem).hasClass("tooltip-inner"), arrowElem = isTooltip ? elem.querySelector(".tooltip-arrow") : elem.querySelector(".arrow");
                if (arrowElem) {
                    var arrowCss = {
                        top: "",
                        bottom: "",
                        left: "",
                        right: ""
                    };
                    if (placement = this.parsePlacement(placement), "center" === placement[1]) return void angular.element(arrowElem).css(arrowCss);
                    var borderProp = "border-" + placement[0] + "-width", borderWidth = $window.getComputedStyle(arrowElem)[borderProp], borderRadiusProp = "border-";
                    borderRadiusProp += PLACEMENT_REGEX.vertical.test(placement[0]) ? placement[0] + "-" + placement[1] : placement[1] + "-" + placement[0], 
                    borderRadiusProp += "-radius";
                    var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];
                    switch (placement[0]) {
                      case "top":
                        arrowCss.bottom = isTooltip ? "0" : "-" + borderWidth;
                        break;

                      case "bottom":
                        arrowCss.top = isTooltip ? "0" : "-" + borderWidth;
                        break;

                      case "left":
                        arrowCss.right = isTooltip ? "0" : "-" + borderWidth;
                        break;

                      case "right":
                        arrowCss.left = isTooltip ? "0" : "-" + borderWidth;
                    }
                    arrowCss[placement[1]] = borderRadius, angular.element(arrowElem).css(arrowCss);
                }
            }
        }
    };
} ]), angular.module("ui.bootstrap.dropdown", [ "ui.bootstrap.position" ]).constant("uibDropdownConfig", {
    appendToOpenClass: "uib-dropdown-open",
    openClass: "open"
}).service("uibDropdownService", [ "$document", "$rootScope", function($document, $rootScope) {
    var openScope = null;
    this.open = function(dropdownScope, element) {
        openScope || $document.on("click", closeDropdown), openScope && openScope !== dropdownScope && (openScope.isOpen = !1), 
        openScope = dropdownScope;
    }, this.close = function(dropdownScope, element) {
        openScope === dropdownScope && ($document.off("click", closeDropdown), $document.off("keydown", this.keybindFilter), 
        openScope = null);
    };
    var closeDropdown = function(evt) {
        if (openScope && !(evt && "disabled" === openScope.getAutoClose() || evt && 3 === evt.which)) {
            var toggleElement = openScope.getToggleElement();
            if (!(evt && toggleElement && toggleElement[0].contains(evt.target))) {
                var dropdownElement = openScope.getDropdownElement();
                evt && "outsideClick" === openScope.getAutoClose() && dropdownElement && dropdownElement[0].contains(evt.target) || (openScope.focusToggleElement(), 
                openScope.isOpen = !1, $rootScope.$$phase || openScope.$apply());
            }
        }
    };
    this.keybindFilter = function(evt) {
        if (openScope) {
            var dropdownElement = openScope.getDropdownElement(), toggleElement = openScope.getToggleElement(), dropdownElementTargeted = dropdownElement && dropdownElement[0].contains(evt.target), toggleElementTargeted = toggleElement && toggleElement[0].contains(evt.target);
            27 === evt.which ? (evt.stopPropagation(), openScope.focusToggleElement(), closeDropdown()) : openScope.isKeynavEnabled() && [ 38, 40 ].indexOf(evt.which) !== -1 && openScope.isOpen && (dropdownElementTargeted || toggleElementTargeted) && (evt.preventDefault(), 
            evt.stopPropagation(), openScope.focusDropdownEntry(evt.which));
        }
    };
} ]).controller("UibDropdownController", [ "$scope", "$element", "$attrs", "$parse", "uibDropdownConfig", "uibDropdownService", "$animate", "$uibPosition", "$document", "$compile", "$templateRequest", function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
    var templateScope, getIsOpen, self = this, scope = $scope.$new(), appendToOpenClass = dropdownConfig.appendToOpenClass, openClass = dropdownConfig.openClass, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop, appendToBody = !1, appendTo = null, keynavEnabled = !1, body = $document.find("body");
    $element.addClass("dropdown"), this.init = function() {
        if ($attrs.isOpen && (getIsOpen = $parse($attrs.isOpen), setIsOpen = getIsOpen.assign, 
        $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value;
        })), angular.isDefined($attrs.dropdownAppendTo)) {
            var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
            appendToEl && (appendTo = angular.element(appendToEl));
        }
        appendToBody = angular.isDefined($attrs.dropdownAppendToBody), keynavEnabled = angular.isDefined($attrs.keyboardNav), 
        appendToBody && !appendTo && (appendTo = body), appendTo && self.dropdownMenu && (appendTo.append(self.dropdownMenu), 
        $element.on("$destroy", function() {
            self.dropdownMenu.remove();
        }));
    }, this.toggle = function(open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen, angular.isFunction(setIsOpen) && setIsOpen(scope, scope.isOpen), 
        scope.isOpen;
    }, this.isOpen = function() {
        return scope.isOpen;
    }, scope.getToggleElement = function() {
        return self.toggleElement;
    }, scope.getAutoClose = function() {
        return $attrs.autoClose || "always";
    }, scope.getElement = function() {
        return $element;
    }, scope.isKeynavEnabled = function() {
        return keynavEnabled;
    }, scope.focusDropdownEntry = function(keyCode) {
        var elems = self.dropdownMenu ? angular.element(self.dropdownMenu).find("a") : $element.find("ul").eq(0).find("a");
        switch (keyCode) {
          case 40:
            angular.isNumber(self.selectedOption) ? self.selectedOption = self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1 : self.selectedOption = 0;
            break;

          case 38:
            angular.isNumber(self.selectedOption) ? self.selectedOption = 0 === self.selectedOption ? 0 : self.selectedOption - 1 : self.selectedOption = elems.length - 1;
        }
        elems[self.selectedOption].focus();
    }, scope.getDropdownElement = function() {
        return self.dropdownMenu;
    }, scope.focusToggleElement = function() {
        self.toggleElement && self.toggleElement[0].focus();
    }, scope.$watch("isOpen", function(isOpen, wasOpen) {
        if (appendTo && self.dropdownMenu) {
            var css, rightalign, scrollbarPadding, pos = $position.positionElements($element, self.dropdownMenu, "bottom-left", !0), scrollbarWidth = 0;
            if (css = {
                top: pos.top + "px",
                display: isOpen ? "block" : "none"
            }, rightalign = self.dropdownMenu.hasClass("dropdown-menu-right"), rightalign ? (css.left = "auto", 
            scrollbarPadding = $position.scrollbarPadding(appendTo), scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth && (scrollbarWidth = scrollbarPadding.scrollbarWidth), 
            css.right = window.innerWidth - scrollbarWidth - (pos.left + $element.prop("offsetWidth")) + "px") : (css.left = pos.left + "px", 
            css.right = "auto"), !appendToBody) {
                var appendOffset = $position.offset(appendTo);
                css.top = pos.top - appendOffset.top + "px", rightalign ? css.right = window.innerWidth - (pos.left - appendOffset.left + $element.prop("offsetWidth")) + "px" : css.left = pos.left - appendOffset.left + "px";
            }
            self.dropdownMenu.css(css);
        }
        var openContainer = appendTo ? appendTo : $element, hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);
        if (hasOpenClass === !isOpen && $animate[isOpen ? "addClass" : "removeClass"](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {
            angular.isDefined(isOpen) && isOpen !== wasOpen && toggleInvoker($scope, {
                open: !!isOpen
            });
        }), isOpen) self.dropdownMenuTemplateUrl ? $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
            templateScope = scope.$new(), $compile(tplContent.trim())(templateScope, function(dropdownElement) {
                var newEl = dropdownElement;
                self.dropdownMenu.replaceWith(newEl), self.dropdownMenu = newEl, $document.on("keydown", uibDropdownService.keybindFilter);
            });
        }) : $document.on("keydown", uibDropdownService.keybindFilter), scope.focusToggleElement(), 
        uibDropdownService.open(scope, $element); else {
            if (uibDropdownService.close(scope, $element), self.dropdownMenuTemplateUrl) {
                templateScope && templateScope.$destroy();
                var newEl = angular.element('<ul class="dropdown-menu"></ul>');
                self.dropdownMenu.replaceWith(newEl), self.dropdownMenu = newEl;
            }
            self.selectedOption = null;
        }
        angular.isFunction(setIsOpen) && setIsOpen($scope, isOpen);
    });
} ]).directive("uibDropdown", function() {
    return {
        controller: "UibDropdownController",
        link: function(scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init();
        }
    };
}).directive("uibDropdownMenu", function() {
    return {
        restrict: "A",
        require: "?^uibDropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl && !angular.isDefined(attrs.dropdownNested)) {
                element.addClass("dropdown-menu");
                var tplUrl = attrs.templateUrl;
                tplUrl && (dropdownCtrl.dropdownMenuTemplateUrl = tplUrl), dropdownCtrl.dropdownMenu || (dropdownCtrl.dropdownMenu = element);
            }
        }
    };
}).directive("uibDropdownToggle", function() {
    return {
        require: "?^uibDropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl) {
                element.addClass("dropdown-toggle"), dropdownCtrl.toggleElement = element;
                var toggleDropdown = function(event) {
                    event.preventDefault(), element.hasClass("disabled") || attrs.disabled || scope.$apply(function() {
                        dropdownCtrl.toggle();
                    });
                };
                element.bind("click", toggleDropdown), element.attr({
                    "aria-haspopup": !0,
                    "aria-expanded": !1
                }), scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
                    element.attr("aria-expanded", !!isOpen);
                }), scope.$on("$destroy", function() {
                    element.unbind("click", toggleDropdown);
                });
            }
        }
    };
}), angular.module("ui.bootstrap.stackedMap", []).factory("$$stackedMap", function() {
    return {
        createNew: function() {
            var stack = [];
            return {
                add: function(key, value) {
                    stack.push({
                        key: key,
                        value: value
                    });
                },
                get: function(key) {
                    for (var i = 0; i < stack.length; i++) if (key === stack[i].key) return stack[i];
                },
                keys: function() {
                    for (var keys = [], i = 0; i < stack.length; i++) keys.push(stack[i].key);
                    return keys;
                },
                top: function() {
                    return stack[stack.length - 1];
                },
                remove: function(key) {
                    for (var idx = -1, i = 0; i < stack.length; i++) if (key === stack[i].key) {
                        idx = i;
                        break;
                    }
                    return stack.splice(idx, 1)[0];
                },
                removeTop: function() {
                    return stack.pop();
                },
                length: function() {
                    return stack.length;
                }
            };
        }
    };
}), angular.module("ui.bootstrap.modal", [ "ui.bootstrap.stackedMap", "ui.bootstrap.position" ]).factory("$$multiMap", function() {
    return {
        createNew: function() {
            var map = {};
            return {
                entries: function() {
                    return Object.keys(map).map(function(key) {
                        return {
                            key: key,
                            value: map[key]
                        };
                    });
                },
                get: function(key) {
                    return map[key];
                },
                hasKey: function(key) {
                    return !!map[key];
                },
                keys: function() {
                    return Object.keys(map);
                },
                put: function(key, value) {
                    map[key] || (map[key] = []), map[key].push(value);
                },
                remove: function(key, value) {
                    var values = map[key];
                    if (values) {
                        var idx = values.indexOf(value);
                        idx !== -1 && values.splice(idx, 1), values.length || delete map[key];
                    }
                }
            };
        }
    };
}).provider("$uibResolve", function() {
    var resolve = this;
    this.resolver = null, this.setResolver = function(resolver) {
        this.resolver = resolver;
    }, this.$get = [ "$injector", "$q", function($injector, $q) {
        var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
        return {
            resolve: function(invocables, locals, parent, self) {
                if (resolver) return resolver.resolve(invocables, locals, parent, self);
                var promises = [];
                return angular.forEach(invocables, function(value) {
                    angular.isFunction(value) || angular.isArray(value) ? promises.push($q.resolve($injector.invoke(value))) : angular.isString(value) ? promises.push($q.resolve($injector.get(value))) : promises.push($q.resolve(value));
                }), $q.all(promises).then(function(resolves) {
                    var resolveObj = {}, resolveIter = 0;
                    return angular.forEach(invocables, function(value, key) {
                        resolveObj[key] = resolves[resolveIter++];
                    }), resolveObj;
                });
            }
        };
    } ];
}).directive("uibModalBackdrop", [ "$animate", "$injector", "$uibModalStack", function($animate, $injector, $modalStack) {
    function linkFn(scope, element, attrs) {
        attrs.modalInClass && ($animate.addClass(element, attrs.modalInClass), scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            scope.modalOptions.animation ? $animate.removeClass(element, attrs.modalInClass).then(done) : done();
        }));
    }
    return {
        restrict: "A",
        compile: function(tElement, tAttrs) {
            return tElement.addClass(tAttrs.backdropClass), linkFn;
        }
    };
} ]).directive("uibModalWindow", [ "$uibModalStack", "$q", "$animateCss", "$document", function($modalStack, $q, $animateCss, $document) {
    return {
        scope: {
            index: "@"
        },
        restrict: "A",
        transclude: !0,
        templateUrl: function(tElement, tAttrs) {
            return tAttrs.templateUrl || "uib/template/modal/window.html";
        },
        link: function(scope, element, attrs) {
            element.addClass(attrs.windowTopClass || ""), scope.size = attrs.size, scope.close = function(evt) {
                var modal = $modalStack.getTop();
                modal && modal.value.backdrop && "static" !== modal.value.backdrop && evt.target === evt.currentTarget && (evt.preventDefault(), 
                evt.stopPropagation(), $modalStack.dismiss(modal.key, "backdrop click"));
            }, element.on("click", scope.close), scope.$isRendered = !0;
            var modalRenderDeferObj = $q.defer();
            scope.$$postDigest(function() {
                modalRenderDeferObj.resolve();
            }), modalRenderDeferObj.promise.then(function() {
                var animationPromise = null;
                attrs.modalInClass && (animationPromise = $animateCss(element, {
                    addClass: attrs.modalInClass
                }).start(), scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                    var done = setIsAsync();
                    $animateCss(element, {
                        removeClass: attrs.modalInClass
                    }).start().then(done);
                })), $q.when(animationPromise).then(function() {
                    var modal = $modalStack.getTop();
                    if (modal && $modalStack.modalRendered(modal.key), !$document[0].activeElement || !element[0].contains($document[0].activeElement)) {
                        var inputWithAutofocus = element[0].querySelector("[autofocus]");
                        inputWithAutofocus ? inputWithAutofocus.focus() : element[0].focus();
                    }
                });
            });
        }
    };
} ]).directive("uibModalAnimationClass", function() {
    return {
        compile: function(tElement, tAttrs) {
            tAttrs.modalAnimation && tElement.addClass(tAttrs.uibModalAnimationClass);
        }
    };
}).directive("uibModalTransclude", [ "$animate", function($animate) {
    return {
        link: function(scope, element, attrs, controller, transclude) {
            transclude(scope.$parent, function(clone) {
                element.empty(), $animate.enter(clone, element);
            });
        }
    };
} ]).factory("$uibModalStack", [ "$animate", "$animateCss", "$document", "$compile", "$rootScope", "$q", "$$multiMap", "$$stackedMap", "$uibPosition", function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
    function snake_case(name) {
        var separator = "-";
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    function isVisible(element) {
        return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
    }
    function backdropIndex() {
        for (var topBackdropIndex = -1, opened = openedWindows.keys(), i = 0; i < opened.length; i++) openedWindows.get(opened[i]).value.backdrop && (topBackdropIndex = i);
        return topBackdropIndex > -1 && topBackdropIndex < topModalIndex && (topBackdropIndex = topModalIndex), 
        topBackdropIndex;
    }
    function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value, appendToElement = modalWindow.appendTo;
        openedWindows.remove(modalInstance), previousTopOpenedModal = openedWindows.top(), 
        previousTopOpenedModal && (topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr("index"), 10)), 
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
            var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
            openedClasses.remove(modalBodyClass, modalInstance);
            var areAnyOpen = openedClasses.hasKey(modalBodyClass);
            appendToElement.toggleClass(modalBodyClass, areAnyOpen), !areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth && (scrollbarPadding.originalRight ? appendToElement.css({
                paddingRight: scrollbarPadding.originalRight + "px"
            }) : appendToElement.css({
                paddingRight: ""
            }), scrollbarPadding = null), toggleTopWindowClass(!0);
        }, modalWindow.closedDeferred), checkRemoveBackdrop(), elementToReceiveFocus && elementToReceiveFocus.focus ? elementToReceiveFocus.focus() : appendToElement.focus && appendToElement.focus();
    }
    function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;
        openedWindows.length() > 0 && (modalWindow = openedWindows.top().value, modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || "", toggleSwitch));
    }
    function checkRemoveBackdrop() {
        if (backdropDomEl && backdropIndex() === -1) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, function() {
                backdropScopeRef = null;
            }), backdropDomEl = void 0, backdropScope = void 0;
        }
    }
    function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        function afterAnimating() {
            afterAnimating.done || (afterAnimating.done = !0, $animate.leave(domEl).then(function() {
                done && done(), domEl.remove(), closedDeferred && closedDeferred.resolve();
            }), scope.$destroy());
        }
        var asyncDeferred, asyncPromise = null, setIsAsync = function() {
            return asyncDeferred || (asyncDeferred = $q.defer(), asyncPromise = asyncDeferred.promise), 
            function() {
                asyncDeferred.resolve();
            };
        };
        return scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync), $q.when(asyncPromise).then(afterAnimating);
    }
    function keydownListener(evt) {
        if (evt.isDefaultPrevented()) return evt;
        var modal = openedWindows.top();
        if (modal) switch (evt.which) {
          case 27:
            modal.value.keyboard && (evt.preventDefault(), $rootScope.$apply(function() {
                $modalStack.dismiss(modal.key, "escape key press");
            }));
            break;

          case 9:
            var list = $modalStack.loadFocusElementList(modal), focusChanged = !1;
            evt.shiftKey ? ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) && (focusChanged = $modalStack.focusLastFocusableElement(list)) : $modalStack.isFocusInLastItem(evt, list) && (focusChanged = $modalStack.focusFirstFocusableElement(list)), 
            focusChanged && (evt.preventDefault(), evt.stopPropagation());
        }
    }
    function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast("modal.closing", resultOrReason, closing).defaultPrevented;
    }
    function unhideBackgroundElements() {
        Array.prototype.forEach.call(document.querySelectorAll("[" + ARIA_HIDDEN_ATTRIBUTE_NAME + "]"), function(hiddenEl) {
            var ariaHiddenCount = parseInt(hiddenEl.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10), newHiddenCount = ariaHiddenCount - 1;
            hiddenEl.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, newHiddenCount), newHiddenCount || (hiddenEl.removeAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 
            hiddenEl.removeAttribute("aria-hidden"));
        });
    }
    var backdropDomEl, backdropScope, scrollbarPadding, OPENED_MODAL_CLASS = "modal-open", openedWindows = $$stackedMap.createNew(), openedClasses = $$multiMap.createNew(), $modalStack = {
        NOW_CLOSING_EVENT: "modal.stack.now-closing"
    }, topModalIndex = 0, previousTopOpenedModal = null, ARIA_HIDDEN_ATTRIBUTE_NAME = "data-bootstrap-modal-aria-hidden-count", tabbableSelector = "a[href], area[href], input:not([disabled]):not([tabindex='-1']), button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']), textarea:not([disabled]):not([tabindex='-1']), iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]", SNAKE_CASE_REGEXP = /[A-Z]/g;
    return $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        backdropScope && (backdropScope.index = newBackdropIndex);
    }), $document.on("keydown", keydownListener), $rootScope.$on("$destroy", function() {
        $document.off("keydown", keydownListener);
    }), $modalStack.open = function(modalInstance, modal) {
        function applyAriaHidden(el) {
            function getSiblings(el) {
                var children = el.parent() ? el.parent().children() : [];
                return Array.prototype.filter.call(children, function(child) {
                    return child !== el[0];
                });
            }
            if (el && "BODY" !== el[0].tagName) return getSiblings(el).forEach(function(sibling) {
                var elemIsAlreadyHidden = "true" === sibling.getAttribute("aria-hidden"), ariaHiddenCount = parseInt(sibling.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10);
                ariaHiddenCount || (ariaHiddenCount = elemIsAlreadyHidden ? 1 : 0), sibling.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, ariaHiddenCount + 1), 
                sibling.setAttribute("aria-hidden", "true");
            }), applyAriaHidden(el.parent());
        }
        var modalOpener = $document[0].activeElement, modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
        toggleTopWindowClass(!1), previousTopOpenedModal = openedWindows.top(), openedWindows.add(modalInstance, {
            deferred: modal.deferred,
            renderDeferred: modal.renderDeferred,
            closedDeferred: modal.closedDeferred,
            modalScope: modal.scope,
            backdrop: modal.backdrop,
            keyboard: modal.keyboard,
            openedClass: modal.openedClass,
            windowTopClass: modal.windowTopClass,
            animation: modal.animation,
            appendTo: modal.appendTo
        }), openedClasses.put(modalBodyClass, modalInstance);
        var appendToElement = modal.appendTo, currBackdropIndex = backdropIndex();
        if (!appendToElement.length) throw new Error("appendTo element not found. Make sure that the element passed is in DOM.");
        currBackdropIndex >= 0 && !backdropDomEl && (backdropScope = $rootScope.$new(!0), 
        backdropScope.modalOptions = modal, backdropScope.index = currBackdropIndex, backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>'), 
        backdropDomEl.attr({
            "class": "modal-backdrop",
            "ng-style": "{'z-index': 1040 + (index && 1 || 0) + index*10}",
            "uib-modal-animation-class": "fade",
            "modal-in-class": "in"
        }), modal.backdropClass && backdropDomEl.addClass(modal.backdropClass), modal.animation && backdropDomEl.attr("modal-animation", "true"), 
        $compile(backdropDomEl)(backdropScope), $animate.enter(backdropDomEl, appendToElement), 
        $uibPosition.isScrollable(appendToElement) && (scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement), 
        scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth && appendToElement.css({
            paddingRight: scrollbarPadding.right + "px"
        })));
        var content;
        modal.component ? (content = document.createElement(snake_case(modal.component.name)), 
        content = angular.element(content), content.attr({
            resolve: "$resolve",
            "modal-instance": "$uibModalInstance",
            close: "$close($value)",
            dismiss: "$dismiss($value)"
        })) : content = modal.content, topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr("index"), 10) + 1 : 0;
        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
            "class": "modal",
            "template-url": modal.windowTemplateUrl,
            "window-top-class": modal.windowTopClass,
            role: "dialog",
            "aria-labelledby": modal.ariaLabelledBy,
            "aria-describedby": modal.ariaDescribedBy,
            size: modal.size,
            index: topModalIndex,
            animate: "animate",
            "ng-style": "{'z-index': 1050 + $$topModalIndex*10, display: 'block'}",
            tabindex: -1,
            "uib-modal-animation-class": "fade",
            "modal-in-class": "in"
        }).append(content), modal.windowClass && angularDomEl.addClass(modal.windowClass), 
        modal.animation && angularDomEl.attr("modal-animation", "true"), appendToElement.addClass(modalBodyClass), 
        modal.scope && (modal.scope.$$topModalIndex = topModalIndex), $animate.enter($compile(angularDomEl)(modal.scope), appendToElement), 
        openedWindows.top().value.modalDomEl = angularDomEl, openedWindows.top().value.modalOpener = modalOpener, 
        applyAriaHidden(angularDomEl);
    }, $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        return unhideBackgroundElements(), modalWindow && broadcastClosing(modalWindow, result, !0) ? (modalWindow.value.modalScope.$$uibDestructionScheduled = !0, 
        modalWindow.value.deferred.resolve(result), removeModalWindow(modalInstance, modalWindow.value.modalOpener), 
        !0) : !modalWindow;
    }, $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        return unhideBackgroundElements(), modalWindow && broadcastClosing(modalWindow, reason, !1) ? (modalWindow.value.modalScope.$$uibDestructionScheduled = !0, 
        modalWindow.value.deferred.reject(reason), removeModalWindow(modalInstance, modalWindow.value.modalOpener), 
        !0) : !modalWindow;
    }, $modalStack.dismissAll = function(reason) {
        for (var topModal = this.getTop(); topModal && this.dismiss(topModal.key, reason); ) topModal = this.getTop();
    }, $modalStack.getTop = function() {
        return openedWindows.top();
    }, $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        $modalStack.focusFirstFocusableElement($modalStack.loadFocusElementList(modalWindow)), 
        modalWindow && modalWindow.value.renderDeferred.resolve();
    }, $modalStack.focusFirstFocusableElement = function(list) {
        return list.length > 0 && (list[0].focus(), !0);
    }, $modalStack.focusLastFocusableElement = function(list) {
        return list.length > 0 && (list[list.length - 1].focus(), !0);
    }, $modalStack.isModalFocused = function(evt, modalWindow) {
        if (evt && modalWindow) {
            var modalDomEl = modalWindow.value.modalDomEl;
            if (modalDomEl && modalDomEl.length) return (evt.target || evt.srcElement) === modalDomEl[0];
        }
        return !1;
    }, $modalStack.isFocusInFirstItem = function(evt, list) {
        return list.length > 0 && (evt.target || evt.srcElement) === list[0];
    }, $modalStack.isFocusInLastItem = function(evt, list) {
        return list.length > 0 && (evt.target || evt.srcElement) === list[list.length - 1];
    }, $modalStack.loadFocusElementList = function(modalWindow) {
        if (modalWindow) {
            var modalDomE1 = modalWindow.value.modalDomEl;
            if (modalDomE1 && modalDomE1.length) {
                var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
                return elements ? Array.prototype.filter.call(elements, function(element) {
                    return isVisible(element);
                }) : elements;
            }
        }
    }, $modalStack;
} ]).provider("$uibModal", function() {
    var $modalProvider = {
        options: {
            animation: !0,
            backdrop: !0,
            keyboard: !0
        },
        $get: [ "$rootScope", "$q", "$document", "$templateRequest", "$controller", "$uibResolve", "$uibModalStack", function($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
            function getTemplatePromise(options) {
                return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl);
            }
            var $modal = {}, promiseChain = null;
            return $modal.getPromiseChain = function() {
                return promiseChain;
            }, $modal.open = function(modalOptions) {
                function resolveWithTemplate() {
                    return templateAndResolvePromise;
                }
                var modalResultDeferred = $q.defer(), modalOpenedDeferred = $q.defer(), modalClosedDeferred = $q.defer(), modalRenderDeferred = $q.defer(), modalInstance = {
                    result: modalResultDeferred.promise,
                    opened: modalOpenedDeferred.promise,
                    closed: modalClosedDeferred.promise,
                    rendered: modalRenderDeferred.promise,
                    close: function(result) {
                        return $modalStack.close(modalInstance, result);
                    },
                    dismiss: function(reason) {
                        return $modalStack.dismiss(modalInstance, reason);
                    }
                };
                if (modalOptions = angular.extend({}, $modalProvider.options, modalOptions), modalOptions.resolve = modalOptions.resolve || {}, 
                modalOptions.appendTo = modalOptions.appendTo || $document.find("body").eq(0), !modalOptions.component && !modalOptions.template && !modalOptions.templateUrl) throw new Error("One of component or template or templateUrl options is required.");
                var templateAndResolvePromise;
                templateAndResolvePromise = modalOptions.component ? $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null)) : $q.all([ getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null) ]);
                var samePromise;
                return samePromise = promiseChain = $q.all([ promiseChain ]).then(resolveWithTemplate, resolveWithTemplate).then(function(tplAndVars) {
                    function constructLocals(obj, template, instanceOnScope, injectable) {
                        obj.$scope = modalScope, obj.$scope.$resolve = {}, instanceOnScope ? obj.$scope.$uibModalInstance = modalInstance : obj.$uibModalInstance = modalInstance;
                        var resolves = template ? tplAndVars[1] : tplAndVars;
                        angular.forEach(resolves, function(value, key) {
                            injectable && (obj[key] = value), obj.$scope.$resolve[key] = value;
                        });
                    }
                    var providedScope = modalOptions.scope || $rootScope, modalScope = providedScope.$new();
                    modalScope.$close = modalInstance.close, modalScope.$dismiss = modalInstance.dismiss, 
                    modalScope.$on("$destroy", function() {
                        modalScope.$$uibDestructionScheduled || modalScope.$dismiss("$uibUnscheduledDestruction");
                    });
                    var ctrlInstance, ctrlInstantiate, modal = {
                        scope: modalScope,
                        deferred: modalResultDeferred,
                        renderDeferred: modalRenderDeferred,
                        closedDeferred: modalClosedDeferred,
                        animation: modalOptions.animation,
                        backdrop: modalOptions.backdrop,
                        keyboard: modalOptions.keyboard,
                        backdropClass: modalOptions.backdropClass,
                        windowTopClass: modalOptions.windowTopClass,
                        windowClass: modalOptions.windowClass,
                        windowTemplateUrl: modalOptions.windowTemplateUrl,
                        ariaLabelledBy: modalOptions.ariaLabelledBy,
                        ariaDescribedBy: modalOptions.ariaDescribedBy,
                        size: modalOptions.size,
                        openedClass: modalOptions.openedClass,
                        appendTo: modalOptions.appendTo
                    }, component = {}, ctrlLocals = {};
                    modalOptions.component ? (constructLocals(component, !1, !0, !1), component.name = modalOptions.component, 
                    modal.component = component) : modalOptions.controller && (constructLocals(ctrlLocals, !0, !1, !0), 
                    ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, !0, modalOptions.controllerAs), 
                    modalOptions.controllerAs && modalOptions.bindToController && (ctrlInstance = ctrlInstantiate.instance, 
                    ctrlInstance.$close = modalScope.$close, ctrlInstance.$dismiss = modalScope.$dismiss, 
                    angular.extend(ctrlInstance, {
                        $resolve: ctrlLocals.$scope.$resolve
                    }, providedScope)), ctrlInstance = ctrlInstantiate(), angular.isFunction(ctrlInstance.$onInit) && ctrlInstance.$onInit()), 
                    modalOptions.component || (modal.content = tplAndVars[0]), $modalStack.open(modalInstance, modal), 
                    modalOpenedDeferred.resolve(!0);
                }, function(reason) {
                    modalOpenedDeferred.reject(reason), modalResultDeferred.reject(reason);
                })["finally"](function() {
                    promiseChain === samePromise && (promiseChain = null);
                }), modalInstance;
            }, $modal;
        } ]
    };
    return $modalProvider;
}), angular.module("ui.bootstrap.tooltip", [ "ui.bootstrap.position", "ui.bootstrap.stackedMap" ]).provider("$uibTooltip", function() {
    function snake_case(name) {
        var regexp = /[A-Z]/g, separator = "-";
        return name.replace(regexp, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var defaultOptions = {
        placement: "top",
        placementClassPrefix: "",
        animation: !0,
        popupDelay: 0,
        popupCloseDelay: 0,
        useContentExp: !1
    }, triggerMap = {
        mouseenter: "mouseleave",
        click: "click",
        outsideClick: "outsideClick",
        focus: "blur",
        none: ""
    }, globalOptions = {};
    this.options = function(value) {
        angular.extend(globalOptions, value);
    }, this.setTriggers = function(triggers) {
        angular.extend(triggerMap, triggers);
    }, this.$get = [ "$window", "$compile", "$timeout", "$document", "$uibPosition", "$interpolate", "$rootScope", "$parse", "$$stackedMap", function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
        function keypressListener(e) {
            if (27 === e.which) {
                var last = openedTooltips.top();
                last && (last.value.close(), last = null);
            }
        }
        var openedTooltips = $$stackedMap.createNew();
        return $document.on("keyup", keypressListener), $rootScope.$on("$destroy", function() {
            $document.off("keyup", keypressListener);
        }), function(ttType, prefix, defaultTriggerShow, options) {
            function getTriggers(trigger) {
                var show = (trigger || options.trigger || defaultTriggerShow).split(" "), hide = show.map(function(trigger) {
                    return triggerMap[trigger] || trigger;
                });
                return {
                    show: show,
                    hide: hide
                };
            }
            options = angular.extend({}, defaultOptions, globalOptions, options);
            var directiveName = snake_case(ttType), startSym = $interpolate.startSymbol(), endSym = $interpolate.endSymbol(), template = "<div " + directiveName + '-popup uib-title="' + startSym + "title" + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + "content" + endSym + '" ') + 'origin-scope="origScope" class="uib-position-measure ' + prefix + '" tooltip-animation-class="fade"uib-tooltip-classes ng-class="{ in: isOpen }" ></div>';
            return {
                compile: function(tElem, tAttrs) {
                    var tooltipLinker = $compile(template);
                    return function(scope, element, attrs, tooltipCtrl) {
                        function toggleTooltipBind() {
                            ttScope.isOpen ? hideTooltipBind() : showTooltipBind();
                        }
                        function showTooltipBind() {
                            hasEnableExp && !scope.$eval(attrs[prefix + "Enable"]) || (cancelHide(), prepareTooltip(), 
                            ttScope.popupDelay ? showTimeout || (showTimeout = $timeout(show, ttScope.popupDelay, !1)) : show());
                        }
                        function hideTooltipBind() {
                            cancelShow(), ttScope.popupCloseDelay ? hideTimeout || (hideTimeout = $timeout(hide, ttScope.popupCloseDelay, !1)) : hide();
                        }
                        function show() {
                            return cancelShow(), cancelHide(), ttScope.content ? (createTooltip(), void ttScope.$evalAsync(function() {
                                ttScope.isOpen = !0, assignIsOpen(!0), positionTooltip();
                            })) : angular.noop;
                        }
                        function cancelShow() {
                            showTimeout && ($timeout.cancel(showTimeout), showTimeout = null), positionTimeout && ($timeout.cancel(positionTimeout), 
                            positionTimeout = null);
                        }
                        function hide() {
                            ttScope && ttScope.$evalAsync(function() {
                                ttScope && (ttScope.isOpen = !1, assignIsOpen(!1), ttScope.animation ? transitionTimeout || (transitionTimeout = $timeout(removeTooltip, 150, !1)) : removeTooltip());
                            });
                        }
                        function cancelHide() {
                            hideTimeout && ($timeout.cancel(hideTimeout), hideTimeout = null), transitionTimeout && ($timeout.cancel(transitionTimeout), 
                            transitionTimeout = null);
                        }
                        function createTooltip() {
                            tooltip || (tooltipLinkedScope = ttScope.$new(), tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                                appendToBody ? $document.find("body").append(tooltip) : element.after(tooltip);
                            }), openedTooltips.add(ttScope, {
                                close: hide
                            }), prepObservers());
                        }
                        function removeTooltip() {
                            cancelShow(), cancelHide(), unregisterObservers(), tooltip && (tooltip.remove(), 
                            tooltip = null, adjustmentTimeout && $timeout.cancel(adjustmentTimeout)), openedTooltips.remove(ttScope), 
                            tooltipLinkedScope && (tooltipLinkedScope.$destroy(), tooltipLinkedScope = null);
                        }
                        function prepareTooltip() {
                            ttScope.title = attrs[prefix + "Title"], contentParse ? ttScope.content = contentParse(scope) : ttScope.content = attrs[ttType], 
                            ttScope.popupClass = attrs[prefix + "Class"], ttScope.placement = angular.isDefined(attrs[prefix + "Placement"]) ? attrs[prefix + "Placement"] : options.placement;
                            var placement = $position.parsePlacement(ttScope.placement);
                            lastPlacement = placement[1] ? placement[0] + "-" + placement[1] : placement[0];
                            var delay = parseInt(attrs[prefix + "PopupDelay"], 10), closeDelay = parseInt(attrs[prefix + "PopupCloseDelay"], 10);
                            ttScope.popupDelay = isNaN(delay) ? options.popupDelay : delay, ttScope.popupCloseDelay = isNaN(closeDelay) ? options.popupCloseDelay : closeDelay;
                        }
                        function assignIsOpen(isOpen) {
                            isOpenParse && angular.isFunction(isOpenParse.assign) && isOpenParse.assign(scope, isOpen);
                        }
                        function prepObservers() {
                            observers.length = 0, contentParse ? (observers.push(scope.$watch(contentParse, function(val) {
                                ttScope.content = val, !val && ttScope.isOpen && hide();
                            })), observers.push(tooltipLinkedScope.$watch(function() {
                                repositionScheduled || (repositionScheduled = !0, tooltipLinkedScope.$$postDigest(function() {
                                    repositionScheduled = !1, ttScope && ttScope.isOpen && positionTooltip();
                                }));
                            }))) : observers.push(attrs.$observe(ttType, function(val) {
                                ttScope.content = val, !val && ttScope.isOpen ? hide() : positionTooltip();
                            })), observers.push(attrs.$observe(prefix + "Title", function(val) {
                                ttScope.title = val, ttScope.isOpen && positionTooltip();
                            })), observers.push(attrs.$observe(prefix + "Placement", function(val) {
                                ttScope.placement = val ? val : options.placement, ttScope.isOpen && positionTooltip();
                            }));
                        }
                        function unregisterObservers() {
                            observers.length && (angular.forEach(observers, function(observer) {
                                observer();
                            }), observers.length = 0);
                        }
                        function bodyHideTooltipBind(e) {
                            ttScope && ttScope.isOpen && tooltip && (element[0].contains(e.target) || tooltip[0].contains(e.target) || hideTooltipBind());
                        }
                        function prepTriggers() {
                            var showTriggers = [], hideTriggers = [], val = scope.$eval(attrs[prefix + "Trigger"]);
                            unregisterTriggers(), angular.isObject(val) ? (Object.keys(val).forEach(function(key) {
                                showTriggers.push(key), hideTriggers.push(val[key]);
                            }), triggers = {
                                show: showTriggers,
                                hide: hideTriggers
                            }) : triggers = getTriggers(val), "none" !== triggers.show && triggers.show.forEach(function(trigger, idx) {
                                "outsideClick" === trigger ? (element.on("click", toggleTooltipBind), $document.on("click", bodyHideTooltipBind)) : trigger === triggers.hide[idx] ? element.on(trigger, toggleTooltipBind) : trigger && (element.on(trigger, showTooltipBind), 
                                element.on(triggers.hide[idx], hideTooltipBind)), element.on("keypress", function(e) {
                                    27 === e.which && hideTooltipBind();
                                });
                            });
                        }
                        var tooltip, tooltipLinkedScope, transitionTimeout, showTimeout, hideTimeout, positionTimeout, adjustmentTimeout, lastPlacement, appendToBody = !!angular.isDefined(options.appendToBody) && options.appendToBody, triggers = getTriggers(void 0), hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]), ttScope = scope.$new(!0), repositionScheduled = !1, isOpenParse = !!angular.isDefined(attrs[prefix + "IsOpen"]) && $parse(attrs[prefix + "IsOpen"]), contentParse = !!options.useContentExp && $parse(attrs[ttType]), observers = [], positionTooltip = function() {
                            tooltip && tooltip.html() && (positionTimeout || (positionTimeout = $timeout(function() {
                                var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody), initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop("offsetHeight"), elementPos = appendToBody ? $position.offset(element) : $position.position(element);
                                tooltip.css({
                                    top: ttPosition.top + "px",
                                    left: ttPosition.left + "px"
                                });
                                var placementClasses = ttPosition.placement.split("-");
                                tooltip.hasClass(placementClasses[0]) || (tooltip.removeClass(lastPlacement.split("-")[0]), 
                                tooltip.addClass(placementClasses[0])), tooltip.hasClass(options.placementClassPrefix + ttPosition.placement) || (tooltip.removeClass(options.placementClassPrefix + lastPlacement), 
                                tooltip.addClass(options.placementClassPrefix + ttPosition.placement)), adjustmentTimeout = $timeout(function() {
                                    var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop("offsetHeight"), adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
                                    adjustment && tooltip.css(adjustment), adjustmentTimeout = null;
                                }, 0, !1), tooltip.hasClass("uib-position-measure") ? ($position.positionArrow(tooltip, ttPosition.placement), 
                                tooltip.removeClass("uib-position-measure")) : lastPlacement !== ttPosition.placement && $position.positionArrow(tooltip, ttPosition.placement), 
                                lastPlacement = ttPosition.placement, positionTimeout = null;
                            }, 0, !1)));
                        };
                        ttScope.origScope = scope, ttScope.isOpen = !1, ttScope.contentExp = function() {
                            return ttScope.content;
                        }, attrs.$observe("disabled", function(val) {
                            val && cancelShow(), val && ttScope.isOpen && hide();
                        }), isOpenParse && scope.$watch(isOpenParse, function(val) {
                            ttScope && !val === ttScope.isOpen && toggleTooltipBind();
                        });
                        var unregisterTriggers = function() {
                            triggers.show.forEach(function(trigger) {
                                "outsideClick" === trigger ? element.off("click", toggleTooltipBind) : (element.off(trigger, showTooltipBind), 
                                element.off(trigger, toggleTooltipBind));
                            }), triggers.hide.forEach(function(trigger) {
                                "outsideClick" === trigger ? $document.off("click", bodyHideTooltipBind) : element.off(trigger, hideTooltipBind);
                            });
                        };
                        prepTriggers();
                        var animation = scope.$eval(attrs[prefix + "Animation"]);
                        ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                        var appendToBodyVal, appendKey = prefix + "AppendToBody";
                        appendToBodyVal = appendKey in attrs && void 0 === attrs[appendKey] || scope.$eval(attrs[appendKey]), 
                        appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody, 
                        scope.$on("$destroy", function() {
                            unregisterTriggers(), removeTooltip(), ttScope = null;
                        });
                    };
                }
            };
        };
    } ];
}).directive("uibTooltipTemplateTransclude", [ "$animate", "$sce", "$compile", "$templateRequest", function($animate, $sce, $compile, $templateRequest) {
    return {
        link: function(scope, elem, attrs) {
            var currentScope, previousElement, currentElement, origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope), changeCounter = 0, cleanupLastIncludeContent = function() {
                previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                currentScope = null), currentElement && ($animate.leave(currentElement).then(function() {
                    previousElement = null;
                }), previousElement = currentElement, currentElement = null);
            };
            console.log("origScope", origScope), scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
                var thisChangeId = ++changeCounter;
                src ? ($templateRequest(src, !0).then(function(response) {
                    if (thisChangeId === changeCounter) {
                        var newScope = origScope.$new(), template = response, clone = $compile(template)(newScope, function(clone) {
                            cleanupLastIncludeContent(), $animate.enter(clone, elem);
                        });
                        currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src);
                    }
                }, function() {
                    thisChangeId === changeCounter && (cleanupLastIncludeContent(), scope.$emit("$includeContentError", src));
                }), scope.$emit("$includeContentRequested", src)) : cleanupLastIncludeContent();
            }), scope.$on("$destroy", cleanupLastIncludeContent);
        }
    };
} ]).directive("uibTooltipClasses", [ "$uibPosition", function($uibPosition) {
    return {
        restrict: "A",
        link: function(scope, element, attrs) {
            if (scope.placement) {
                var position = $uibPosition.parsePlacement(scope.placement);
                element.addClass(position[0]);
            }
            scope.popupClass && element.addClass(scope.popupClass), scope.animation && element.addClass(attrs.tooltipAnimationClass);
        }
    };
} ]).directive("uibTooltipPopup", function() {
    return {
        restrict: "A",
        scope: {
            content: "@"
        },
        templateUrl: "uib/template/tooltip/tooltip-popup.html"
    };
}).directive("uibTooltip", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltip", "tooltip", "mouseenter");
} ]).directive("uibTooltipTemplatePopup", function() {
    return {
        restrict: "A",
        scope: {
            contentExp: "&",
            originScope: "&"
        },
        templateUrl: "uib/template/tooltip/tooltip-template-popup.html"
    };
}).directive("uibTooltipTemplate", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltipTemplate", "tooltip", "mouseenter", {
        useContentExp: !0
    });
} ]).directive("uibTooltipHtmlPopup", function() {
    return {
        restrict: "A",
        scope: {
            contentExp: "&"
        },
        templateUrl: "uib/template/tooltip/tooltip-html-popup.html"
    };
}).directive("uibTooltipHtml", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltipHtml", "tooltip", "mouseenter", {
        useContentExp: !0
    });
} ]), angular.module("ui.bootstrap.popover", [ "ui.bootstrap.tooltip" ]).directive("uibPopoverTemplatePopup", function() {
    return {
        restrict: "A",
        scope: {
            uibTitle: "@",
            contentExp: "&",
            originScope: "&"
        },
        templateUrl: "uib/template/popover/popover-template.html"
    };
}).directive("uibPopoverTemplate", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopoverTemplate", "popover", "click", {
        useContentExp: !0
    });
} ]).directive("uibPopoverHtmlPopup", function() {
    return {
        restrict: "A",
        scope: {
            contentExp: "&",
            uibTitle: "@"
        },
        templateUrl: "uib/template/popover/popover-html.html"
    };
}).directive("uibPopoverHtml", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopoverHtml", "popover", "click", {
        useContentExp: !0
    });
} ]).directive("uibPopoverPopup", function() {
    return {
        restrict: "A",
        scope: {
            uibTitle: "@",
            content: "@"
        },
        templateUrl: "uib/template/popover/popover.html"
    };
}).directive("uibPopover", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopover", "popover", "click", {
        placementClassPrefix: "popover-"
    });
} ]), angular.module("ui.bootstrap.debounce", []).factory("$$debounce", [ "$timeout", function($timeout) {
    return function(callback, debounceTime) {
        var timeoutPromise;
        return function() {
            var self = this, args = Array.prototype.slice.call(arguments);
            timeoutPromise && $timeout.cancel(timeoutPromise), timeoutPromise = $timeout(function() {
                callback.apply(self, args);
            }, debounceTime);
        };
    };
} ]), angular.module("ui.bootstrap.typeahead", [ "ui.bootstrap.debounce", "ui.bootstrap.position" ]).factory("uibTypeaheadParser", [ "$parse", function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
        parse: function(input) {
            var match = input.match(TYPEAHEAD_REGEXP);
            if (!match) throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "' + input + '".');
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            };
        }
    };
} ]).controller("UibTypeaheadController", [ "$scope", "$element", "$attrs", "$compile", "$parse", "$q", "$timeout", "$document", "$window", "$rootScope", "$$debounce", "$uibPosition", "uibTypeaheadParser", function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
    function fireRecalculating() {
        scope.moveInProgress || (scope.moveInProgress = !0, scope.$digest()), debouncedRecalculate();
    }
    function recalculatePosition() {
        scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
        scope.position.top += element.prop("offsetHeight");
    }
    var modelCtrl, ngModelOptions, HOT_KEYS = [ 9, 13, 27, 38, 40 ], eventDebounceTime = 200, minLength = originalScope.$eval(attrs.typeaheadMinLength);
    minLength || 0 === minLength || (minLength = 1), originalScope.$watch(attrs.typeaheadMinLength, function(newVal) {
        minLength = newVal || 0 === newVal ? newVal : 1;
    });
    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0, isEditable = originalScope.$eval(attrs.typeaheadEditable) !== !1;
    originalScope.$watch(attrs.typeaheadEditable, function(newVal) {
        isEditable = newVal !== !1;
    });
    var hasFocus, selected, isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop, isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {
        var evt = vals.$event;
        return 13 === evt.which || 9 === evt.which;
    }, onSelectCallback = $parse(attrs.typeaheadOnSelect), isSelectOnBlur = !!angular.isDefined(attrs.typeaheadSelectOnBlur) && originalScope.$eval(attrs.typeaheadSelectOnBlur), isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop, inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : void 0, appendToBody = !!attrs.typeaheadAppendToBody && originalScope.$eval(attrs.typeaheadAppendToBody), appendTo = attrs.typeaheadAppendTo ? originalScope.$eval(attrs.typeaheadAppendTo) : null, focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== !1, selectOnExact = !!attrs.typeaheadSelectOnExact && originalScope.$eval(attrs.typeaheadSelectOnExact), isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop, showHint = originalScope.$eval(attrs.typeaheadShowHint) || !1, parsedModel = $parse(attrs.ngModel), invokeModelSetter = $parse(attrs.ngModel + "($$$p)"), $setModelValue = function(scope, newValue) {
        return angular.isFunction(parsedModel(originalScope)) && ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter ? invokeModelSetter(scope, {
            $$$p: newValue
        }) : parsedModel.assign(scope, newValue);
    }, parserResult = typeaheadParser.parse(attrs.uibTypeahead), scope = originalScope.$new(), offDestroy = originalScope.$on("$destroy", function() {
        scope.$destroy();
    });
    scope.$on("$destroy", offDestroy);
    var popupId = "typeahead-" + scope.$id + "-" + Math.floor(1e4 * Math.random());
    element.attr({
        "aria-autocomplete": "list",
        "aria-expanded": !1,
        "aria-owns": popupId
    });
    var inputsContainer, hintInputElem;
    showHint && (inputsContainer = angular.element("<div></div>"), inputsContainer.css("position", "relative"), 
    element.after(inputsContainer), hintInputElem = element.clone(), hintInputElem.attr("placeholder", ""), 
    hintInputElem.attr("tabindex", "-1"), hintInputElem.val(""), hintInputElem.css({
        position: "absolute",
        top: "0px",
        left: "0px",
        "border-color": "transparent",
        "box-shadow": "none",
        opacity: 1,
        background: "none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)",
        color: "#999"
    }), element.css({
        position: "relative",
        "vertical-align": "top",
        "background-color": "transparent"
    }), hintInputElem.attr("id") && hintInputElem.removeAttr("id"), inputsContainer.append(hintInputElem), 
    hintInputElem.after(element));
    var popUpEl = angular.element("<div uib-typeahead-popup></div>");
    popUpEl.attr({
        id: popupId,
        matches: "matches",
        active: "activeIdx",
        select: "select(activeIdx, evt)",
        "move-in-progress": "moveInProgress",
        query: "query",
        position: "position",
        "assign-is-open": "assignIsOpen(isOpen)",
        debounce: "debounceUpdate"
    }), angular.isDefined(attrs.typeaheadTemplateUrl) && popUpEl.attr("template-url", attrs.typeaheadTemplateUrl), 
    angular.isDefined(attrs.typeaheadPopupTemplateUrl) && popUpEl.attr("popup-template-url", attrs.typeaheadPopupTemplateUrl);
    var resetHint = function() {
        showHint && hintInputElem.val("");
    }, resetMatches = function() {
        scope.matches = [], scope.activeIdx = -1, element.attr("aria-expanded", !1), resetHint();
    }, getMatchId = function(index) {
        return popupId + "-option-" + index;
    };
    scope.$watch("activeIdx", function(index) {
        index < 0 ? element.removeAttr("aria-activedescendant") : element.attr("aria-activedescendant", getMatchId(index));
    });
    var inputIsExactMatch = function(inputValue, index) {
        return !!(scope.matches.length > index && inputValue) && inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
    }, getMatchesAsync = function(inputValue, evt) {
        var locals = {
            $viewValue: inputValue
        };
        isLoadingSetter(originalScope, !0), isNoResultsSetter(originalScope, !1), $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
            var onCurrentRequest = inputValue === modelCtrl.$viewValue;
            if (onCurrentRequest && hasFocus) if (matches && matches.length > 0) {
                scope.activeIdx = focusFirst ? 0 : -1, isNoResultsSetter(originalScope, !1), scope.matches.length = 0;
                for (var i = 0; i < matches.length; i++) locals[parserResult.itemName] = matches[i], 
                scope.matches.push({
                    id: getMatchId(i),
                    label: parserResult.viewMapper(scope, locals),
                    model: matches[i]
                });
                if (scope.query = inputValue, recalculatePosition(), element.attr("aria-expanded", !0), 
                selectOnExact && 1 === scope.matches.length && inputIsExactMatch(inputValue, 0) && (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate) ? $$debounce(function() {
                    scope.select(0, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate["default"]) : scope.select(0, evt)), 
                showHint) {
                    var firstLabel = scope.matches[0].label;
                    angular.isString(inputValue) && inputValue.length > 0 && firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase() ? hintInputElem.val(inputValue + firstLabel.slice(inputValue.length)) : hintInputElem.val("");
                }
            } else resetMatches(), isNoResultsSetter(originalScope, !0);
            onCurrentRequest && isLoadingSetter(originalScope, !1);
        }, function() {
            resetMatches(), isLoadingSetter(originalScope, !1), isNoResultsSetter(originalScope, !0);
        });
    };
    appendToBody && (angular.element($window).on("resize", fireRecalculating), $document.find("body").on("scroll", fireRecalculating));
    var debouncedRecalculate = $$debounce(function() {
        scope.matches.length && recalculatePosition(), scope.moveInProgress = !1;
    }, eventDebounceTime);
    scope.moveInProgress = !1, scope.query = void 0;
    var timeoutPromise, scheduleSearchWithTimeout = function(inputValue) {
        timeoutPromise = $timeout(function() {
            getMatchesAsync(inputValue);
        }, waitTime);
    }, cancelPreviousTimeout = function() {
        timeoutPromise && $timeout.cancel(timeoutPromise);
    };
    resetMatches(), scope.assignIsOpen = function(isOpen) {
        isOpenSetter(originalScope, isOpen);
    }, scope.select = function(activeIdx, evt) {
        var model, item, locals = {};
        selected = !0, locals[parserResult.itemName] = item = scope.matches[activeIdx].model, 
        model = parserResult.modelMapper(originalScope, locals), $setModelValue(originalScope, model), 
        modelCtrl.$setValidity("editable", !0), modelCtrl.$setValidity("parse", !0), onSelectCallback(originalScope, {
            $item: item,
            $model: model,
            $label: parserResult.viewMapper(originalScope, locals),
            $event: evt
        }), resetMatches(), scope.$eval(attrs.typeaheadFocusOnSelect) !== !1 && $timeout(function() {
            element[0].focus();
        }, 0, !1);
    }, element.on("keydown", function(evt) {
        if (0 !== scope.matches.length && HOT_KEYS.indexOf(evt.which) !== -1) {
            var shouldSelect = isSelectEvent(originalScope, {
                $event: evt
            });
            if (scope.activeIdx === -1 && shouldSelect || 9 === evt.which && evt.shiftKey) return resetMatches(), 
            void scope.$digest();
            evt.preventDefault();
            var target;
            switch (evt.which) {
              case 27:
                evt.stopPropagation(), resetMatches(), originalScope.$digest();
                break;

              case 38:
                scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1, 
                scope.$digest(), target = popUpEl[0].querySelectorAll(".uib-typeahead-match")[scope.activeIdx], 
                target.parentNode.scrollTop = target.offsetTop;
                break;

              case 40:
                scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length, scope.$digest(), 
                target = popUpEl[0].querySelectorAll(".uib-typeahead-match")[scope.activeIdx], target.parentNode.scrollTop = target.offsetTop;
                break;

              default:
                shouldSelect && scope.$apply(function() {
                    angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate) ? $$debounce(function() {
                        scope.select(scope.activeIdx, evt);
                    }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate["default"]) : scope.select(scope.activeIdx, evt);
                });
            }
        }
    }), element.bind("focus", function(evt) {
        hasFocus = !0, 0 !== minLength || modelCtrl.$viewValue || $timeout(function() {
            getMatchesAsync(modelCtrl.$viewValue, evt);
        }, 0);
    }), element.bind("blur", function(evt) {
        isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected && (selected = !0, 
        scope.$apply(function() {
            angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur) ? $$debounce(function() {
                scope.select(scope.activeIdx, evt);
            }, scope.debounceUpdate.blur) : scope.select(scope.activeIdx, evt);
        })), !isEditable && modelCtrl.$error.editable && (modelCtrl.$setViewValue(), scope.$apply(function() {
            modelCtrl.$setValidity("editable", !0), modelCtrl.$setValidity("parse", !0);
        }), element.val("")), hasFocus = !1, selected = !1;
    });
    var dismissClickHandler = function(evt) {
        element[0] !== evt.target && 3 !== evt.which && 0 !== scope.matches.length && (resetMatches(), 
        $rootScope.$$phase || originalScope.$digest());
    };
    $document.on("click", dismissClickHandler), originalScope.$on("$destroy", function() {
        $document.off("click", dismissClickHandler), (appendToBody || appendTo) && $popup.remove(), 
        appendToBody && (angular.element($window).off("resize", fireRecalculating), $document.find("body").off("scroll", fireRecalculating)), 
        popUpEl.remove(), showHint && inputsContainer.remove();
    });
    var $popup = $compile(popUpEl)(scope);
    appendToBody ? $document.find("body").append($popup) : appendTo ? angular.element(appendTo).eq(0).append($popup) : element.after($popup), 
    this.init = function(_modelCtrl, _ngModelOptions) {
        modelCtrl = _modelCtrl, ngModelOptions = _ngModelOptions, scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope), 
        modelCtrl.$parsers.unshift(function(inputValue) {
            return hasFocus = !0, 0 === minLength || inputValue && inputValue.length >= minLength ? waitTime > 0 ? (cancelPreviousTimeout(), 
            scheduleSearchWithTimeout(inputValue)) : getMatchesAsync(inputValue) : (isLoadingSetter(originalScope, !1), 
            cancelPreviousTimeout(), resetMatches()), isEditable ? inputValue : inputValue ? void modelCtrl.$setValidity("editable", !1) : (modelCtrl.$setValidity("editable", !0), 
            null);
        }), modelCtrl.$formatters.push(function(modelValue) {
            var candidateViewValue, emptyViewValue, locals = {};
            return isEditable || modelCtrl.$setValidity("editable", !0), inputFormatter ? (locals.$model = modelValue, 
            inputFormatter(originalScope, locals)) : (locals[parserResult.itemName] = modelValue, 
            candidateViewValue = parserResult.viewMapper(originalScope, locals), locals[parserResult.itemName] = void 0, 
            emptyViewValue = parserResult.viewMapper(originalScope, locals), candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue);
        });
    };
} ]).directive("uibTypeahead", function() {
    return {
        controller: "UibTypeaheadController",
        require: [ "ngModel", "^?ngModelOptions", "uibTypeahead" ],
        link: function(originalScope, element, attrs, ctrls) {
            ctrls[2].init(ctrls[0], ctrls[1]);
        }
    };
}).directive("uibTypeaheadPopup", [ "$$debounce", function($$debounce) {
    return {
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "&",
            moveInProgress: "=",
            select: "&",
            assignIsOpen: "&",
            debounce: "&"
        },
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.popupTemplateUrl || "uib/template/typeahead/typeahead-popup.html";
        },
        link: function(scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl, scope.isOpen = function() {
                var isDropdownOpen = scope.matches.length > 0;
                return scope.assignIsOpen({
                    isOpen: isDropdownOpen
                }), isDropdownOpen;
            }, scope.isActive = function(matchIdx) {
                return scope.active === matchIdx;
            }, scope.selectActive = function(matchIdx) {
                scope.active = matchIdx;
            }, scope.selectMatch = function(activeIdx, evt) {
                var debounce = scope.debounce();
                angular.isNumber(debounce) || angular.isObject(debounce) ? $$debounce(function() {
                    scope.select({
                        activeIdx: activeIdx,
                        evt: evt
                    });
                }, angular.isNumber(debounce) ? debounce : debounce["default"]) : scope.select({
                    activeIdx: activeIdx,
                    evt: evt
                });
            };
        }
    };
} ]).directive("uibTypeaheadMatch", [ "$templateRequest", "$compile", "$parse", function($templateRequest, $compile, $parse) {
    return {
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, attrs) {
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "uib/template/typeahead/typeahead-match.html";
            $templateRequest(tplUrl).then(function(tplContent) {
                var tplEl = angular.element(tplContent.trim());
                element.replaceWith(tplEl), $compile(tplEl)(scope);
            });
        }
    };
} ]).filter("uibTypeaheadHighlight", [ "$sce", "$injector", "$log", function($sce, $injector, $log) {
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }
    function containsHtml(matchItem) {
        return /<.*>/g.test(matchItem);
    }
    var isSanitizePresent;
    return isSanitizePresent = $injector.has("$sanitize"), function(matchItem, query) {
        return !isSanitizePresent && containsHtml(matchItem) && $log.warn("Unsafe use of typeahead please use ngSanitize"), 
        matchItem = query ? ("" + matchItem).replace(new RegExp(escapeRegexp(query), "gi"), "<strong>$&</strong>") : matchItem, 
        isSanitizePresent || (matchItem = $sce.trustAsHtml(matchItem)), matchItem;
    };
} ]), angular.module("uib/template/modal/window.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/modal/window.html", "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n");
} ]), angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-html-popup.html", '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner" ng-bind-html="contentExp()"></div>\n');
} ]), angular.module("uib/template/tooltip/tooltip-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-popup.html", '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner" ng-bind="content"></div>\n');
} ]), angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-template-popup.html", '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner"\n  uib-tooltip-template-transclude="contentExp()"\n  tooltip-template-transclude-scope="originScope()"></div>\n');
} ]), angular.module("uib/template/popover/popover-html.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover-html.html", '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content" ng-bind-html="contentExp()"></div>\n</div>\n');
} ]), angular.module("uib/template/popover/popover-template.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover-template.html", '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content"\n      uib-tooltip-template-transclude="contentExp()"\n      tooltip-template-transclude-scope="originScope()"></div>\n</div>\n');
} ]), angular.module("uib/template/popover/popover.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover.html", '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content" ng-bind="content"></div>\n</div>\n');
} ]), angular.module("uib/template/typeahead/typeahead-match.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-match.html", '<a href\n    class="dropdown-item"\n   tabindex="-1"\n   ng-bind-html="match.label | uibTypeaheadHighlight:query"\n   ng-attr-title="{{match.label}}"></a>\n');
} ]), angular.module("uib/template/typeahead/typeahead-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-popup.html", '<div\n  class="dropdown-menu"\n  ng-show="isOpen() && !moveInProgress"\n  ng-style="{top: position().top+\'px\', left: position().left+\'px\'}"\n  role="listbox"\n  aria-hidden="{{!isOpen()}}">\n    <div\n      class="uib-typeahead-match"\n      ng-repeat="match in matches track by $index"\n      ng-class="{active: isActive($index) }"\n      ng-mouseenter="selectActive($index)"\n      ng-click="selectMatch($index, $event)"\n      role="option"\n      id="{{::match.id}}">\n        <div\n          uib-typeahead-match\n          index="$index"\n          match="match"\n          query="query"\n          template-url="templateUrl">\n        </div>\n    </div>\n</div>\n');
} ]), angular.module("ui.bootstrap.position").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'), 
    angular.$$uibPositionCss = !0;
}), angular.module("ui.bootstrap.tooltip").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find("head").prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'), 
    angular.$$uibTooltipCss = !0;
}), angular.module("ui.bootstrap.typeahead").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find("head").prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'), 
    angular.$$uibTypeaheadCss = !0;
});
//# sourceMappingURL=ui-bootstrap-custom-2.4.0.map